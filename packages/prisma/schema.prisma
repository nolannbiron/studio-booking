generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["fullTextSearch"]
}

// generator zod {
//     provider      = "zod-prisma"
//     output        = "./zod"
//     imports       = "./zod-utils"
//     relationModel = "default"
// }

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

generator enums {
    provider = "tsx ./enum-generator"
}

enum AuthProvider {
    JWT
    GOOGLE
    FACEBOOK
}

enum Locale {
    fr
    en
}

model User {
    id            String    @id @default(uuid())
    firstName     String
    lastName      String
    fullName      String
    avatarUrl     String
    avatarColor   String?
    email         String    @unique
    password      String?
    locale        Locale?   @default(en)
    isRoot        Boolean   @default(false)
    /// @zod.custom(imports.userMetadata)
    metadata      Json?
    emailVerified DateTime?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    authProvider   AuthProvider @default(JWT)
    authProviderId String?

    teams    Membership[]
    accounts Account[]
    notes    Note[]
    tasks    Task[]       @relation("AssignedTasks")
    Booking  Booking[]

    @@index([email, password])
    @@map("users")
}

model VerificationToken {
    id            Int      @id @default(autoincrement())
    identifier    String
    token         String   @unique
    expires       DateTime
    expiresInDays Int?
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    team   Team?   @relation(fields: [teamId], references: [id])
    teamId String?

    @@unique([identifier, token])
    @@index([token])
    @@index([teamId])
    @@map("verification_tokens")
}

enum MembershipRole {
    MEMBER
    ADMIN
    OWNER
}

model Membership {
    id       String         @id @default(uuid())
    role     MembershipRole @default(MEMBER)
    accepted Boolean        @default(false)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId    String
    userEmail String

    team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
    teamId String

    @@unique([userEmail, teamId])
    @@unique([userId, teamId])
    @@index([userEmail])
    @@index([teamId])
    @@map("memberships")
}

model Team {
    id         String  @id @default(uuid())
    name       String
    slug       String  @unique
    websiteUrl String?
    logoUrl    String?
    /// @zod.custom(imports.teamMetadataSchema)
    metadata   Json?
    color      String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    members            Membership[]
    orgSettings        OrganizationSettings?
    verificationTokens VerificationToken[]
    contacts           Contact[]
    genres             ContactGenre[]
    notes              Note[]
    Task               Task[]
    Booking            Booking[]

    @@map("teams")
}

model OrganizationSettings {
    id                       String  @id @default(uuid())
    organization             Team    @relation(fields: [organizationId], references: [id], onDelete: Cascade)
    organizationId           String  @unique
    isOrganizationConfigured Boolean @default(false)
    isOrganizationVerified   Boolean @default(false)
    orgAutoAcceptEmail       String

    @@map("organization_settings")
}

model Account {
    id                String  @id @default(uuid())
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? @db.Text
    access_token      String? @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? @db.Text
    session_state     String?

    user   User?  @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    userId String

    @@unique([provider, providerAccountId])
    @@index([userId])
    @@index([type])
    @@map("accounts")
}

model StripeProduct {
    id          String  @id
    priceId     String?
    name        String
    description String?
    isActive    Boolean
    isLive      Boolean // is this product live on stripe?
    metadata    Json?

    // those comes from stripe
    createdAt DateTime
    updatedAt DateTime

    features String[]

    @@map("stripe_products")
}

enum FeatureType {
    RELEASE
    EXPERIMENT
    OPERATIONAL
    KILL_SWITCH
    PERMISSION
}

model Feature {
    // The feature slug, ex: 'v2-workflows'
    slug        String       @id @unique
    // If the feature is currently enabled
    enabled     Boolean      @default(false)
    // A short description of the feature
    description String?
    // The type of feature flag
    type        FeatureType? @default(RELEASE)
    // If the flag is considered stale
    stale       Boolean?     @default(false)
    lastUsedAt  DateTime?
    createdAt   DateTime?    @default(now())
    updatedAt   DateTime?    @default(now()) @updatedAt
    updatedBy   String?

    @@index([enabled])
    @@index([stale])
    @@map("features")
}

enum ContactType {
    ARTIST
    BAND
    LABEL
    MANAGER
    CAMERAMAN
    PHOTOGRAPHER
}

model ContactGenre {
    id    String @id @default(uuid())
    title String
    value String
    color String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
    teamId String

    contacts Contact[] @relation("GenreContacts")

    @@unique([teamId, title], name: "unique_genre")
    @@map("contact_genres")
}

model Contact {
    id        String  @id @default(uuid())
    name      String
    email     String?
    phone     String?
    avatarUrl String

    type   ContactType?
    genres ContactGenre[] @relation("GenreContacts")

    instagram String?
    facebook  String?
    twitter   String?
    youtube   String?
    tiktok    String?
    spotify   String?
    snapchat  String?
    website   String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
    teamId String

    avatarColor String?
    bookings    Booking[]

    @@map("contacts")
}

enum EventType {
    ENTITY_CREATED
    VALUES_UPDATED
    NOTE_ADDED
}

model TimelineEvent {
    id    String    @id @default(uuid())
    type  EventType
    event Json

    entityId   String
    entityType String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@index([entityId])
    @@map("activities")
}

model Note {
    id      String @id @default(uuid())
    title   String
    content Json?

    entityId   String
    entityType String

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    creator User   @relation(fields: [ownerId], references: [id], onDelete: Cascade)
    ownerId String

    team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
    teamId String

    @@index([entityId])
    @@index([teamId])
    @@index([ownerId])
    @@index([entityId, entityType])
    @@map("notes")
}

model Task {
    id        String    @id @default(uuid())
    title     String
    dueDate   DateTime?
    completed Boolean   @default(false)

    entityId   String?
    entityType String?

    ownerId String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
    teamId String

    assignees User[] @relation("AssignedTasks")

    @@index([entityId, teamId, dueDate, completed, ownerId])
    @@index([entityId, teamId, dueDate, completed])
    @@index([ownerId, teamId, dueDate, completed])
    @@map("tasks")
}

enum BookingStatus {
    PENDING
    CONFIRMED
    CANCELED
}

model Booking {
    id        String        @id @default(uuid())
    title     String
    content   Json?
    startDate DateTime
    endDate   DateTime
    status    BookingStatus @default(PENDING)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)
    teamId String

    contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
    contactId String

    owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade)
    ownerId String

    @@index([teamId, startDate, status])
    @@index([teamId, ownerId, contactId, startDate, status])
    @@index([teamId, ownerId, startDate, status])
    @@index([teamId, contactId, startDate, status])
    @@map("bookings")
}
